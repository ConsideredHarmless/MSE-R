---
title: Numeric Example
output: pdf_document
---
```{r}
#Set the library's directory first!
mseDirectory="/home/tc/Projects/github/tchronis/MSE-R"
```

```{r setup, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE}
knitr::opts_knit$set(root.dir = mseDirectory)
```

```{r,warning=FALSE,message=FALSE}
#Load Libraries and functions
setwd(mseDirectory)
source("mse.R")
```
## Import precomputed data
Set the data's directory preferably in the variable 'filename'.
```{r }
filename<-paste(mseDirectory,"/import/round1m1-1.xls.pre.dat",sep="")
filename<-paste(mseDirectory,"/import/precomp_proof.dat",sep="")
filename<-paste(mseDirectory,"/import/precomp_testdata.dat",sep="")
```
Load the data in variables with meaningful names
```{r }

library(data.table)

#res <- microbenchmark(
#  read.csv = read.delim(filename, header = TRUE, sep="", as.is=TRUE),
#  fread = data.table::fread(filename, header=TRUE),
#  times = 5)

import2(filename)
head(DT)
class(DT)
typeof(DT)
length(DT)
#attributes(DT)
key(DT)

all.equal(noU,noD)
```
## Routines (calculate payoff matrix, inequalities members, dataArray)
```{r }
#Add new columns
#fields = c("payoff")
x1=2;x2=3;x3=1;x4=1;x5=-1;
DT[, payoff := 1+dist1*x1+dist2*x2+dist3*x3+dist4*x4+dist5*x5]
#DT[,payoff:=NULL]
View(DT[Match==1,])

# Calculating inequality members
DTmatched<-DT[Match==1,.(Market,UpStream,DownStream)]
ineqmembers<-merge(DTmatched,DTmatched,by="Market",no.dups = FALSE,allow.cartesian=TRUE,all=TRUE)
ineqmembers<-ineqmembers[UpStream.x < UpStream.y,.(Market,UpStream.x,UpStream.y,DownStream.x,DownStream.y)]
ineqmembers<-ineqmembers[order(Market,UpStream.x,UpStream.y)]
up1<-unique(ineqmembers[,.(Market,UpStream.x,UpStream.y,DownStream.x)])
up2<-unique(ineqmembers[,.(Market,UpStream.x,UpStream.y,DownStream.y)])




Market -> m
i -> D(i)
j -> D(j)
Factual:
f(
 p(m,i,D1(i)),p(m,i,D2(i)),...,p(m,i,Dk(i)),
 p(m,j,D1(j)),p(m,j,D2(j)),...,p(m,j,Dl(j))
)
CounterFactual:
f(
 p(m,i,D1(j)),p(m,i,D2(j)),...,p(m,i,Dl(j)),
 p(m,j,D1(i)),p(m,j,D2(i)),...,p(m,j,Dk(i))
)

data table (dependent on mate)
m,i,j,factual(true/false),pairIndex(++),d1,d2,...,dN,payoff

calculate payoff using x vector

aggregate(factual,counterFactual)

aggregate per market

aggregateAll



#Create payoffMatrix
Cx<-Cx(noAttr)
payoffMatrix<-CpayoffMatrix(noM,noU,noD,Cx,distanceMatrices,noAttr)
noD
#Assign payoffMatrix numerical values (set x's)
xval<-c(1,2)
payoffMatrix<-assignpayoffMatrix(payoffMatrix,xval)
```

```{r }
#Create inequality members
ineqmembers<-Cineqmembers(mate)
```

```{r }
#Create Data Array
dataArray<-CdataArray(distanceMatrices,ineqmembers)
```

## Maximization

### Differential Evolution Method
The default DifferentialEvolution parameters:

\begin{table}[]
\centering
\begin{tabular}{lll}
option name & default value   & \\ \hline
lower,upper & -10,10          & two vectors specifying scalar real lower and upper bounds on each parameter to be optimized, so that the i-th element of lower and upper applies to the i-th parameter. The implementation searches between lower and upper for the global optimum (minimum) of fn.\\
CR          & 0.5             & crossover probability from interval [0,1]\\
trace       & FALSE           & Positive integer or logical value indicating whether printing of progress occurs at each iteration\\
itermax     & 100             & the maximum iteration (population generation) allowed\\
F           & 0.6             & differential weighting factor from interval [0,2]\\
NP          & 50              & number of population members. Defaults to NA; if the user does not change the value of NP from NA or specifies a value less than 4 it is reset when DEoptim is called as 10*length(lower). For many problems it is best to set NP to be at least 10 times the length of the parameter vector.\\
reltol      & 0.001           & relative convergence tolerance. The algorithm stops if it is unable to reduce the value by a factor of reltol * (abs(val) + reltol) after steptol steps\\
RandomSeed  & 0               &  Random Seed to be used for result reproducibility 
\end{tabular}
\end{table}

```{r }
#Objective function
coefficient1<-1
b<-Cx #Define x1,x2,... values
#obj<-objective(b)

#maximize function
lower <- c(-10, -10)
upper <- -lower
par<-list(lower=lower,upper=upper,NP=50,itermax=100,trace=FALSE,reltol=0.001,CR=0.5,F=0.6,RandomSeed=0)
x<-maximize(par)
g(bestmem,bestval)%=%x
print(bestmem)
print(bestval)
```

## Confidence Intervals
#Generate random subsample
```{r }
#Create groupIDs
groupIDs<-groupIDs(ineqmembers)


ssSize<-3

options<-list()
options["progressUpdate"]<-1
options["confidenceLevel"]<-0.95
options["asymptotics"]<-"nests"
options["symmetric"]<-FALSE

numSubsamples<-50
pointEstimate<-as.numeric(bestmem)
b<-Cx[2:3]


lower <- c(-10, -10)
upper <- -lower
par<-list(lower=lower,upper=upper,NP=50,itermax=100,trace=FALSE,reltol=0.001,CR=0.5,F=0.6,RandomSeed=0)


pointIdentifiedCR(ssSize, numSubsamples,pointEstimate,Cx,groupIDs,dataArray,options,par)
```
