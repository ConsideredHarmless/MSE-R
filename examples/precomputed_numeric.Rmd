---
title: Numeric Example
output: pdf_document
---
```{r}
#Set the library's directory first!
mseDirectory<-"/home/tc/Projects/github/tchronis/MSE-R"
```

```{r setup, include=FALSE,warning=FALSE,echo=FALSE,message=FALSE}
knitr::opts_knit$set(root.dir = mseDirectory)
```

```{r,warning=FALSE,message=FALSE}
#Load Libraries and functions
setwd(mseDirectory)
source("mse.R")
```
## Import precomputed data
Set the data's directory preferably in the variable 'filename'.
```{r }
filename<-paste(mseDirectory,"/import/round1m1-1.xls.pre.dat",sep="")
filename<-paste(mseDirectory,"/import/precomp_proof.dat",sep="")
filename<-paste(mseDirectory,"/import/precomp_testdata.dat",sep="")
```
Load the data in variables with meaningful names
```{r }

library(data.table)

#res <- microbenchmark(
#  read.csv = read.delim(filename, header = TRUE, sep="", as.is=TRUE),
#  fread = data.table::fread(filename, header=TRUE),
#  times = 5)

import2(filename)
head(DT)
class(DT)
typeof(DT)
length(DT)
#attributes(DT)
key(DT)

all.equal(noU,noD)
```
## Routines (calculate payoff matrix, inequalities members, dataArray)
```{r }
#Add new columns
#fields = c("payoff")
x1=2;x2=3;x3=1;x4=1;x5=-1;
DT[, payoff := 1+dist1*x1+dist2*x2+dist3*x3+dist4*x4+dist5*x5]
#DT[,payoff:=NULL]
View(DT[Match==1,])

# Calculating inequality members
matched<-DT[Match==1,.(Market,UpStream,DownStream)]
ineqmembers<-merge(matched,matched,by="Market",no.dups = FALSE,allow.cartesian=TRUE,all=TRUE)
ineqmembers<-ineqmembers[UpStream.x < UpStream.y] #,.(Market,UpStream.x,UpStream.y,DownStream.x,DownStream.y,dist1.x)]
ineqmembers<-ineqmembers[order(Market,UpStream.x,UpStream.y)]

up1<-unique(ineqmembers[,.(Market,UpStream.x,UpStream.y,DownStream.x)])
setnames(up1,"UpStream.x","UpStream")
setnames(up1,"UpStream.y","UpStream2")
setnames(up1,"DownStream.x","DownStream")
setkey(up1,Market,UpStream,DownStream)
up1<-DT[up1]
setnames(up1,"UpStream","UpStream1")
up1<-up1[order(Market,UpStream1,UpStream2,DownStream)]

up2<-unique(ineqmembers[,.(Market,UpStream.x,UpStream.y,DownStream.y)])
setnames(up2, "UpStream.y", "UpStream")
setnames(up2,"DownStream.y","DownStream")
setnames(up2, "UpStream.x", "UpStream1")
setkey(up2,Market,UpStream,DownStream)
up2<-DT[up2]
setnames(up2,"UpStream","UpStream2")
up2<-up2[order(Market,UpStream1,UpStream2,DownStream)]

up3<-unique(ineqmembers[,.(Market,UpStream.x,UpStream.y,DownStream.y)])
setnames(up3,"UpStream.x","UpStream")
setnames(up3,"UpStream.y","UpStream2")
setnames(up3,"DownStream.y","DownStream")
setkey(up3,Market,UpStream,DownStream)
up3<-DT[up3]
setnames(up3,"UpStream","UpStream1")
up3<-up3[order(Market,UpStream1,UpStream2,DownStream)]

up4<-unique(ineqmembers[,.(Market,UpStream.x,UpStream.y,DownStream.x)])
setnames(up4, "UpStream.y", "UpStream")
setnames(up4,"DownStream.x","DownStream")
setnames(up4, "UpStream.x", "UpStream1")
setkey(up4,Market,UpStream,DownStream)
up4<-DT[up4]
setnames(up4,"UpStream","UpStream2")
up4<-up4[order(Market,UpStream1,UpStream2,DownStream)]

x1=2;x2=3;x3=1;

up1[, payoff := 1+Distance1*x1+Distance2*x2+Distance3]
up1N<-up1[,.N,by=c("Market","UpStream1","UpStream2")]
up1P<-up1[,sum(payoff),by=c("Market","UpStream1","UpStream2")]

up2[, payoff := 1+Distance1*x1+Distance2*x2+Distance3]
up2N<-up2[,.N,by=c("Market","UpStream1","UpStream2")]
up2P<-up2[,sum(payoff),by=c("Market","UpStream1","UpStream2")]

up3[, payoff := 1+Distance1*x1+Distance2*x2+Distance3]
up3N<-up3[,.N,by=c("Market","UpStream1","UpStream2")]
up3P<-up3[,sum(payoff),by=c("Market","UpStream1","UpStream2")]

up4[, payoff := 1+Distance1*x1+Distance2*x2+Distance3]
up4N<-up4[,.N,by=c("Market","UpStream1","UpStream2")]
up4P<-up4[,sum(payoff),by=c("Market","UpStream1","UpStream2")]

uN<-up1N+up2N-up3N-up4N
uP<-up1P+up2P-up3P-up4P



Market -> m
i -> D(i)
j -> D(j)
Factual:
f(
 p(m,i,D1(i)),p(m,i,D2(i)),...,p(m,i,Dk(i)),
 p(m,j,D1(j)),p(m,j,D2(j)),...,p(m,j,Dl(j))
)
CounterFactual:
f(
 p(m,i,D1(j)),p(m,i,D2(j)),...,p(m,i,Dl(j)),
 p(m,j,D1(i)),p(m,j,D2(i)),...,p(m,j,Dk(i))
)

data table (dependent on mate)
m,i,j,factual(true/false),pairIndex(++),d1,d2,...,dN,payoff

calculate payoff using x vector

aggregate(factual,counterFactual)

aggregate per market

aggregateAll



#Create payoffMatrix
Cx<-Cx(noAttr)
payoffMatrix<-CpayoffMatrix(noM,noU,noD,Cx,distanceMatrices,noAttr)
noD
#Assign payoffMatrix numerical values (set x's)
xval<-c(1,2)
payoffMatrix<-assignpayoffMatrix(payoffMatrix,xval)
```

```{r }
#Create inequality members
ineqmembers<-Cineqmembers(mate)
```

```{r }
#Create Data Array
dataArray<-CdataArray(distanceMatrices,ineqmembers)
```

## Maximization

### Differential Evolution Method
The default DifferentialEvolution parameters:

\begin{table}[]
\centering
\begin{tabular}{lll}
option name & default value   & \\ \hline
lower,upper & -10,10          & two vectors specifying scalar real lower and upper bounds on each parameter to be optimized, so that the i-th element of lower and upper applies to the i-th parameter. The implementation searches between lower and upper for the global optimum (minimum) of fn.\\
CR          & 0.5             & crossover probability from interval [0,1]\\
trace       & FALSE           & Positive integer or logical value indicating whether printing of progress occurs at each iteration\\
itermax     & 100             & the maximum iteration (population generation) allowed\\
F           & 0.6             & differential weighting factor from interval [0,2]\\
NP          & 50              & number of population members. Defaults to NA; if the user does not change the value of NP from NA or specifies a value less than 4 it is reset when DEoptim is called as 10*length(lower). For many problems it is best to set NP to be at least 10 times the length of the parameter vector.\\
reltol      & 0.001           & relative convergence tolerance. The algorithm stops if it is unable to reduce the value by a factor of reltol * (abs(val) + reltol) after steptol steps\\
RandomSeed  & 0               &  Random Seed to be used for result reproducibility 
\end{tabular}
\end{table}

```{r }
#Objective function
coefficient1<-1
b<-Cx #Define x1,x2,... values
#obj<-objective(b)

#maximize function
lower <- c(-10, -10)
upper <- -lower
par<-list(lower=lower,upper=upper,NP=50,itermax=100,trace=FALSE,reltol=0.001,CR=0.5,F=0.6,RandomSeed=0)
x<-maximize(par)
g(bestmem,bestval)%=%x
print(bestmem)
print(bestval)
```

## Confidence Intervals
#Generate random subsample
```{r }
#Create groupIDs
groupIDs<-groupIDs(ineqmembers)


ssSize<-3

options<-list()
options["progressUpdate"]<-1
options["confidenceLevel"]<-0.95
options["asymptotics"]<-"nests"
options["symmetric"]<-FALSE

numSubsamples<-50
pointEstimate<-as.numeric(bestmem)
b<-Cx[2:3]


lower <- c(-10, -10)
upper <- -lower
par<-list(lower=lower,upper=upper,NP=50,itermax=100,trace=FALSE,reltol=0.001,CR=0.5,F=0.6,RandomSeed=0)


pointIdentifiedCR(ssSize, numSubsamples,pointEstimate,Cx,groupIDs,dataArray,options,par)
```
