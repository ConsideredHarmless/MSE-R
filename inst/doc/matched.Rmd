---
title: "Calculating optimal parameters from matched data"
author: "Panaghis Mavrokefalos"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Calculating optimal parameters from matched data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# A quick example

```{r setup}
library(maxscoreest)
```

First, we need to import the data into R. Let's use some synthetic data provided
with the package.

```{r}
filename <- system.file("extdata", "precomp_testdata.dat", package = "maxscoreest")
```

We import this using the function `importMatched`.

```{r}
matchedData <- importMatched(filename)
```

Next, we need to calculate the *inequality members*; lists of indices of the
pairings which participate in the inequalities defining the objective function.
The function `Cineqmembers` uses the matching information, contained in the
list member `$mate`, to create these indices.

```{r}
ineqmembers <- Cineqmembers(matchedData$mate)
```

Now we can create use inequality members to create the *data array*. The
function `CdataArray` uses these indices to gather and combine values from the
distance matrices.

```{r}
dataArray <- CdataArray(matchedData$distanceMatrices, ineqmembers)
```

Next, we need to set up the optimization procedure.

---

## An important note regarding optimization

We are optimizing a non-smooth, non-convex objective function, so the
general-purpose optimization methods are ill-suited for this problem. We are
currently supporting only the *Differential Evolution* method (implemented in
the package `DEoptim`), but this is a **non-deterministic** method. A user can
fix the RNG seed on their setup, but there is no guarantee of reproducibility
across different machines, operating systems, R versions, or package versions.

The two facts stated above are also complicating things:

- The objective is non-convex: this means that there is no guarantee of reaching
the global optimum using local search methods.
- The objective is non-smooth, and actually piecewise constant: this means that
the objective attains its (global) optimum for infinitely many points. Even
worse, there are potentially many disconnected subsets of the search space on
which the objective attains its optimum.

Differential Evolution works very well in practice however, either finding the
global optimum or approximating it very closely.

---

Let's use the default parameters for Differential Evolution, and select a box
constraint of $[-100, 100]$.

```{r}
bounds <- makeBounds(matchedData$noAttr, 100)
optimParams <- getDefaultOptimParams()
```

We might also want to fix the RNG for reproducibility across runs. See the
*note regarding optimization* above.

```{r}
randomSeed <- 42
set.seed(randomSeed)
```

We are now ready to perform the optimization. The function
`optimizeScoreFunction` creates and optimizes the objective.
Note that we don't have to pass the arguments via `do.call`, but since we'll
need the argument list later when calculating the confidence region, this way is
more convenient.

```{r}
optimizeScoreArgs <- list(
    dataArray = dataArray,
    bounds = bounds,
    optimParams = optimParams,
    getIneqSat = TRUE,
    permuteInvariant = TRUE)
optResult <- do.call(optimizeScoreFunction, optimizeScoreArgs)
```

We can now see the optimal parameter vector, and how many inequalities are
satisfied across each market.

```{r}
optResult$optArg
optResult$optVal
calcPerMarketStats(optResult$ineqSat, makeGroupIDs(ineqmembers))
```

# Calculating the confidence intervals

Now that we have an optimal solution for the parameters, we can use it to
calculate an estimate for the confidence regions.

Let's choose a number of iterations for the confidence regions calculation
procedure, and the size of the market subsets of each iteration.

```{r}
ssSize <- 2
numSubsamples <- 50
```

We also need to map each inequality to its market, using the function
`makeGroupIDs`.

```{r}
groupIDs <- makeGroupIDs(ineqmembers)
```

Now we are ready to calculate the confidence regions. We choose a confidence
level is equal to $0.95$.

```{r}
confidenceLevel <- 0.95
cr <- pointIdentifiedCR(
    dataArray, groupIDs, optResult$optArg,
    ssSize, numSubsamples, confidenceLevel,
    optimizeScoreArgs)
```

We can use the function `plotCR` to visualize the confidence region estimates.

```{r}
plotCR(cr$estimates)
```

# Taking a closer look
