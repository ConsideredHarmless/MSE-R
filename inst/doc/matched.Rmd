---
title: "Calculating optimal parameters from matched data"
author: "Panaghis Mavrokefalos"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Calculating optimal parameters from matched data}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

# A quick example

```{r setup}
library(maxscoreest)
```

First, we need to import the data into R. Let's use some synthetic data provided
with the package.

```{r}
filename <- system.file("extdata", "precomp_testdata.dat", package = "maxscoreest")
```

We import this using the function `importMatched`.

```{r}
matchedData <- importMatched(filename)
```

Next, we need to calculate the *inequality members*; lists of indices of the
pairings which participate in the inequalities defining the objective function.
The function `Cineqmembers` uses the matching information, contained in the
list member `$mate`, to create these indices.

```{r}
ineqmembers <- Cineqmembers(matchedData$mate)
```

Now we can create use inequality members to create the *data array*. The
function `CdataArray` uses these indices to gather and combine values from the
distance matrices.

```{r}
dataArray <- CdataArray(matchedData$distanceMatrices, ineqmembers)
```

Next, we need to set up the optimization procedure.

---

## An important note regarding optimization

We are optimizing a non-smooth, non-convex objective function, so the
general-purpose optimization methods are ill-suited for this problem. We are
currently supporting only the *Differential Evolution* method (implemented in
the package `DEoptim`), but this is a **non-deterministic** method. A user can
fix the RNG seed on their setup, but there is no guarantee of reproducibility
across different machines, operating systems, R versions, or package versions.

The two facts stated above are also complicating things:

- The objective is non-convex: this means that there is no guarantee of reaching
the global optimum using local search methods.
- The objective is non-smooth, and actually piecewise constant: this means that
the objective attains its (global) optimum for infinitely many points. Even
worse, there are potentially many disconnected subsets of the search space on
which the objective attains its optimum.

Differential Evolution works very well in practice however, either finding the
global optimum or approximating it very closely.

---

Let's use the default parameters for Differential Evolution, and select a box
constraint of $[-100, 100]$.

```{r}
bounds <- makeBounds(matchedData$noAttr, 100)
optimParams <- getDefaultOptimParams()
```

We might also want to fix the RNG for reproducibility across runs. See the
*note regarding optimization* above.

```{r}
randomSeed <- 42
set.seed(randomSeed)
```

We are now ready to perform the optimization. The function
`optimizeScoreFunction` creates and optimizes the objective.
Note that we don't have to pass the arguments via `do.call`, but since we'll
need the argument list later when calculating the confidence region, this way is
more convenient.

```{r}
optimizeScoreArgs <- list(
    dataArray = dataArray,
    bounds = bounds,
    optimParams = optimParams,
    getIneqSat = TRUE,
    permuteInvariant = TRUE)
optResult <- do.call(optimizeScoreFunction, optimizeScoreArgs)
```

We can now see the optimal parameter vector, and how many inequalities are
satisfied across each market.

```{r}
optResult$optArg
optResult$optVal
calcPerMarketStats(optResult$ineqSat, makeGroupIDs(ineqmembers))
```

# Calculating the confidence intervals

Now that we have an optimal solution for the parameters, we can use it to
calculate an estimate for the confidence regions.

Let's choose a number of iterations for the confidence regions calculation
procedure, and the size of the market subsets of each iteration.

```{r}
ssSize <- 2
numSubsamples <- 50
```

We also need to map each inequality to its market, using the function
`makeGroupIDs`.

```{r}
groupIDs <- makeGroupIDs(ineqmembers)
```

Now we are ready to calculate the confidence regions. We choose a confidence
level is equal to $0.95$.

```{r}
confidenceLevel <- 0.95
cr <- pointIdentifiedCR(
    dataArray, groupIDs, optResult$optArg,
    ssSize, numSubsamples, confidenceLevel,
    optimizeScoreArgs)
```

We can use the function `plotCR` to visualize the confidence region estimates.

```{r}
plotCR(cr$estimates)
```

We can also see which market subsets were chosen at each iteration.

```{r}
cr$samples
```

Instead of the point-identified method, we can also use the cube-root bootstrap
method. The signatures are the same:

```{r}
crCubeRoot <- cubeRootBootstrapCR(
    dataArray, groupIDs, optResult$optArg,
    ssSize, numSubsamples, confidenceLevel,
    optimizeScoreArgs)
```

See the vignette *Calculating confidence regions using the cube-root bootstrap method* (accessed by `vignettes("cubeRootBootstrap"`) for more details on this method.

# Taking a closer look

## Importing

The `importMatched` function can handle delimiter-separated value files with
headers. It supports two modes:

- identifying fields by their position (the default)
- identifying fields by their name

The optional argument `fieldMode` switches between those modes.
The exact format of the header and values is explained in more detail in the
documentation.

## Accessing the imported data

We can see how many markets are in the data, how many members each stream
has in each market, and how many attributes there are.

```{r}
matchedData$noM
matchedData$noU
matchedData$noD
matchedData$noAttr
```

We can also view the file header, containing the field names.

```{r}
matchedData$header
```

The `matchedData` structure exposes two elements, called `$distanceMatrices` and
`$matchMatrices`. They are lists of size `noM` each, with each element
containing an array with the relevant data for each market:

```{r}
length(matchedData$distanceMatrices)
length(matchedData$matchMatrices)
```

Let's check whether, in the third market, there is match between the
upstream-downstream pair indexed by $(4, 7)$. Note the order that the indices
appear.

```{r}
mIdx <- 3
uIdx <- 4
dIdx <- 7
matchedData$matchMatrices[[mIdx]][dIdx, uIdx]
```

We can also view the matching information for a single stream.

```{r}
# Leaving an index blank takes all elements for that dimension.
matchedData$matchMatrices[[mIdx]][, uIdx]
# `which` returns the indices where the elements above are `1` -- i.e. the
# downstream matches of upstream '4'.
which(matchedData$matchMatrices[[mIdx]][, uIdx] == 1)
```

We can view the distance attributes for a single attribute index, or for the
entire attribute range.

```{r}
aIdx <- 3
matchedData$distanceMatrices[[mIdx]][aIdx, dIdx, uIdx]
matchedData$distanceMatrices[[mIdx]][, dIdx, uIdx]
```

## Accessing the inequality members

The structure `ineqmembers` is a list of length `noM`. Each element contains
the indices which define each inequality for that market, packaged in a list.

```{r}
mIdx <- 1
length(ineqmembers)
names(ineqmembers[[mIdx]])
```

The `numIneqs` element is the number of inequalities for that market. The
other four elements are lists, with length equal to `numIneqs`.

```{r}
ineqmembers[[mIdx]]$numIneqs
length(ineqmembers[[mIdx]]$fctUpIdxs)
```

Each inequality, when everything has been moved to the LHS, contains terms of
the form $f_{\beta}(m, p, q) - f_{\beta}(m, r, s)$, where $f_{\beta}$ is the
payoff function of the match evaluated at the parameter vector $\beta$, and
$f_{\beta}(m, i, j)$ is its value for the upstream-downstream match $(i, j)$ of
the $m$-th market. The indices $p, q, r, s$ are stored the vectors
`$fctUpIdxs`, `$fctDnIdxs`, `$cfcUpIdxs`, and `$cfcDnIdxs`, respectively,
where `fct` and `cfc` correspond to the factual/LHS $(p, q)$ and
counterfactual/RHS $(r, s)$ indices, and `Up` and `Dn` to the upstream
$(p, r)$ and downstream $(q, s)$ indices.

For example, let's choose the first term of the first inequality for the
previous match:

```{r}
mIdx <- 3
uIdx <- 4
dIdx <- 7
ineqIdx <- 1
termIdx <- 1
ineqmembers[[mIdx]]$fctUpIdxs[[ineqIdx]][termIdx]
ineqmembers[[mIdx]]$fctDnIdxs[[ineqIdx]][termIdx]
ineqmembers[[mIdx]]$cfcUpIdxs[[ineqIdx]][termIdx]
ineqmembers[[mIdx]]$cfcDnIdxs[[ineqIdx]][termIdx]
```

Since the above expressions are cumbersome, we provide the `getIneqTermsIdxs`
and `getAllIneqTermsIdxs` functions, which provide the above information in a
more user-friendly mode. `getIneqTermsIdxs` returns an array with all indices
of a single inequality. `getAllIneqTermsIdxs` does the same for an entire
market.

```{r}
getIneqTermsIdxs(ineqmembers[[mIdx]], ineqIdx)
getAllIneqTermsIdxs(ineqmembers[[mIdx]])[[ineqIdx]]
```

## Accessing the data array

The `dataArray` object is an array with precomputed values used in calculating
the value of the objective function. Its rows correspond to attributes, and its
columns to inequalities.

```{r}
dim(dataArray)
```

The `dataArray` is "flat", in the sense that there is no distinction between
markets. To recover that distinction, we need to create a mapping from its
column indices to the market indices. This is handled by the function
`makeGroupIDs`

```{r}
groupIDs
```

We can now choose the columns corresponding to the second market...

```{r}
mIdx <- 2
qualifiedIndices <- which(groupIDs == mIdx)
qualifiedIndices
dataArray[, qualifiedIndices]
```

...or, more generally, to a subset of market indices:

```{r}
selectedGroups <- c(1, 3)
qualifiedIndices <- which(groupIDs %in% selectedGroups)
qualifiedIndices
```

## Optimization

The function `makeBounds` creates equal symmetrical box constraints for each
variable:

```{r}
makeBounds(matchedData$noAttr, 100)
```

If non-symmetrical constraints are desired, we can pass a third argument to the
function:

```{r}
makeBounds(matchedData$noAttr, 10, -20)
```

Otherwise, we can also create custom bounds. That object should be a list
with elements named `$lower` and `$upper`. Each element is a vector defining
lower and upper bounds for each variable.

```{r}
bounds <- list(lower=c(-1, -2, -3, -5), upper=c(2, 3, 5, 8))
bounds
```

Note that since we have 5 distrance attributes, the number of free parameters
is 4.

`getDefaultOptimParams` returns a reasonable collection of parameters for the
Differential Evolution method.

```{r}
optimParams
```

See the documentation of `DEoptim::DEoptim.control` for more information.

We can also use the original names of the distance attributes for the
optimal parameter vector.

```{r}
distNames <- matchedData$header[matchedData$colIdxs$distanceColIdxs]
# Drop first value.
distNamesFree <- distNames[-1]
names(optResult$optArg) <- distNamesFree
optResult$optArg
```

### Restarting the optimization multiple times

Since we are dealing with an optimization problem with multiple solutions, we
provide an option to restart optimization procedures, such as *Differential
Evolution*, that depend on the state of the random generator. By using a
different random state on each run, the optimal parameter vectors calculated
on each run will also vary. The user can then choose one or more solutions
according to their own criteria.

Setting the parameter `numRuns` in `optimizeScoreFunction()` to an integer
greater than `1` will restart the optimization procedure that many times, then
collect the results that share the overall best score value found in the list
`bestRuns`.

It might be helpful to set the `progressUpdate` parameter to a positive value,
in order to track the progress of the long-running operation.

```{r restartOpt}
optimizeScoreArgs$bounds <- bounds <- makeBounds(matchedData$noAttr, 10)
optimizeScoreArgs$numRuns <- 1000
optimizeScoreArgs$progressUpdate <- 50
optResult <- do.call(optimizeScoreFunction, optimizeScoreArgs)
length(optResult$bestRuns)
optResult$bestRuns[[100]]
```
