% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/maximize.R
\name{optimizeScoreFunction}
\alias{optimizeScoreFunction}
\title{Calculate maximum score}
\usage{
optimizeScoreFunction(
  dataArray,
  bounds,
  coefficient1 = NULL,
  method = NULL,
  optimParams = NULL,
  getIneqSat = FALSE,
  permuteInvariant = TRUE,
  numRuns = 1,
  progressUpdate = 0
)
}
\arguments{
\item{dataArray}{The output of \code{CdataArray}.}

\item{bounds}{A list with elements \code{$lower}, \code{$upper} which are
vectors defining lower and upper bounds for each variable in the objective
function.}

\item{coefficient1}{(optional) The first coefficient of the extended
parameter vector. See \code{makeScoreObjFun} for more details.}

\item{method}{(optional) A string denoting the optimization method.
Currently, only \code{"DEoptim"} (the default value) is supported.}

\item{optimParams}{(optional) A list of parameters to be passed to the
optimization routine. Defaults to the empty list.
See the section "Optimization methods" for more information.}

\item{getIneqSat}{(optional) A boolean indicating whether to include the
\code{$ineqSat} member in the result. Defaults to \code{FALSE}.}

\item{permuteInvariant}{(optional) Whether to reorder the parameters before
and after the optimization, such that the parameter with the smallest
standard deviation comes first. Defaults to \code{TRUE}.}
}
\value{
A list with members:
\tabular{ll}{
\code{$optVal}  \tab The optimal value of the objective function.\cr
\code{$optArg}  \tab The argument vector which achieves that value.\cr
\code{$ineqSat} \tab A vector of \code{0}s and \code{1}s. Each element
corresponds to a single inequality, and is \code{1} if that inequality is
satisfied for the optimal parameters, and \code{0} otherwise. Only
present if \code{getIneqSat} is \code{TRUE}.
}
}
\description{
Optimizes the maximum score function defined by the data array. The objective
function is created using \code{makeScoreObjFun}.
}
\section{Optimization methods}{

The optimization method is not bound to the problem. Any method that can
optimize a non-convex, non-smooth function is valid. However, we currently
only support the \emph{Differential Evolution} method, as implemented in the
package \strong{DEoptim}. In case the user wants to pass parameters to the solver,
we provide the parameter \code{optimParams}, which is forwarded to the
\code{control} parameter of the function \code{DEoptim::DEoptim}.
See \code{DEoptim::DEoptim.control} for more information.
}

