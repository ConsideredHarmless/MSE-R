% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/confidence.R
\name{makeHmatrix}
\alias{makeHmatrix}
\title{\loadmathjax
Create estimator for H matrix}
\usage{
makeHmatrix(dataArray, pointEstimate, options)
}
\arguments{
\item{dataArray}{The output of \code{dataArray}.}

\item{pointEstimate}{The vector \mjseqn{\hat{\beta}} of the optimal
parameters, as calculated by \code{optimizeScoreFunction}.}

\item{options}{See options \code{Hest}, \code{bw}, \code{makePosDef}, \code{makePosDefTol},
\code{Hbypass}, and \code{debugLogging} from \code{\link{newBootstrapCR}}.}
}
\value{
The matrix \mjseqn{H}.
}
\description{
Creates the estimator matrix \mjseqn{\tilde{H}_n} (\mjseqn{H} for short),
used in \code{\link{newBootstrapCR}}. Handles choice of method, correct
set-up of step/bandwidth, its calculation using ROT if required, and
conversion to positive semidefinite.
}
\details{
The construction of \mjseqn{H} is based on the paper by Cattaneo et al.
(2020), linked in the document page of the \code{\link{newBootstrapCR}}
function.
\subsection{Choice of method}{

Two methods for estimating the matrix \mjseqn{H_0} are implemented. The first
uses numerical differentiation, as shown in section 3.1., and the other
creates a "plug-in" estimator for this specific model, as in section 4.1..

The choice of method is controlled by the option \code{Hest}.
\subsection{Plug-in kernel}{

Note that the plug-in estimator method requires a kernel function with
specific properties, as shown in the paper and its supplement. The only
kernel currently available is the function \mjseqn{K(u) = \phi(u)}, i.e. the
pdf of the standard normal distribution, with first derivative
\mjseqn{\dot{K}(u) = -u\phi(u)}.
}

}

\subsection{Step/bandwidth}{

Both methods require a matrix of parameters: for the numerical derivative
method, this is the step \mjseqn{\epsilon_{n,kl}}, and for the plug-in
method, this is the bandwidth \mjseqn{h_{n,kl}}. In both cases, this value
has to be a matrix of size equal to the size of \mjseqn{H}, i.e.
\mjseqn{d \times d}, where \mjseqn{d} is the number of free attributes.

The user can also pass a scalar value for this parameter, in which case it
is automatically converted to a matrix of the appropriate size with
constant elements. However, if the covariates have different scale, then a
matrix with different entry-wise values would be more appropriate.

The parameter scalar or matrix can be passed using the option \code{bw}.
\subsection{Rule-Of-Thumb}{

It is usually the case that the user does not have the correct values of the
step or bandwidth parameters. In this case, they can be automatically
calculated using a method called \emph{Rule-Of-Thumb} (ROT). See the linked
paper and its supplement, as well the function \code{\link{rot}} for more
details. To select this option, the user can set the option \code{bw} to \code{"rot"}.
}

}

\subsection{Conversion to positive semidefinite}{

Although the matrix \mjseqn{H_0} is positive semidefinite, this is not
necessarily the case for its estimate \mjseqn{H}. Since this matrix is used
in a quadratic form in the bootstrap optimization procedure, it can be
useful to replace the matrix calculated with an approximation which
satisfies this requirement.

Consider a non-positive-semidefinite matrix \mjseqn{H}, and let
\mjseqn{\lambda_1 \geq \lambda_2 \geq \dots \geq \lambda_d} be its
eigenvalues in descending order. We provide two approaches:
\enumerate{
\item In the first approach, a constant
\mjseqn{\kappa = \epsilon_{\mathrm{tol}} - \lambda_d} is added to all
diagonal elements of \mjseqn{H}, where \mjseqn{\lambda_d < 0} is the
smallest eigenvalue of \mjseqn{H}, and \mjseqn{\epsilon_{\mathrm{tol}}}
is a non-negative tolerance.
\item In the second approach, all negative eigenvalues of \mjseqn{H} are
replaced with \mjseqn{0}.
}

Note that both \mjseqn{H_0} and \mjseqn{H} are always symmetric by
construction.

The options \code{makePosDef} and \code{makePosDefTol} control this feature.
}

\subsection{Bypassing the calculations}{

The user can also skip the entire calculation of \mjseqn{H} and pass their
own value instead, using the option \code{Hbypass}.
}
}
\keyword{internal}
