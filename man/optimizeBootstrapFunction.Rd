% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/maximize.R
\name{optimizeBootstrapFunction}
\alias{optimizeBootstrapFunction}
\title{Calculate bootstrap estimates}
\usage{
optimizeBootstrapFunction(
  fullDataArray,
  sampleDataArray,
  betaEst,
  H,
  bounds,
  coefficient1 = NULL,
  method = NULL,
  optimParams = NULL,
  useCorrectionFactor = TRUE
)
}
\arguments{
\item{fullDataArray}{The full data array.}

\item{sampleDataArray}{The sample data array.}

\item{betaEst}{The estimate of \eqn{\beta}. This should have been obtained
by calling \code{optimizeScoreFunction} on \code{fullDataArray}.}

\item{H}{The matrix \eqn{H}, as defined in the paper by Cattaneo et al..
Should have
dimensions \mjseqn{d \times d}, where \eqn{d} is the number of free
parameters.}

\item{bounds}{A list with elements \code{$lower}, \code{$upper} which are
vectors defining lower and upper bounds for each variable in the objective
function.}

\item{coefficient1}{(optional) The first coefficient of the extended
parameter vector. See \code{makeScoreObjFun} for more details.}

\item{method}{(optional) A string denoting the optimization method.
Currently, only \code{"DEoptim"} (the default value) is supported.}

\item{optimParams}{(optional) A list of parameters to be passed to the
optimization routine. Defaults to the empty list.
See the section "Optimization methods" for more information.}

\item{useCorrectionFactor}{A boolean selecting whether to apply the
correction factor. If \code{TRUE} (the default value), then
\mjseqn{c = \frac{m}{n}}, otherwise it is \mjseqn{1}.}
}
\value{
A list with members:
\tabular{ll}{
\code{$optVal}  \tab The optimal value of the objective function.\cr
\code{$optArg}  \tab The argument vector which achieves that value.\cr
}
}
\description{
Optimizes the objective function created be \code{makeBootstrapObjFun}. Its
argmax is used internally in the implementation of Cattaneo's bootstrap
method.
}
\section{Optimization methods}{

The optimization method is not bound to the problem. Any method that can
optimize a non-convex, non-smooth function is valid. However, we currently
only support the \emph{Differential Evolution} method, as implemented in the
package \strong{DEoptim}. In case the user wants to pass parameters to the solver,
we provide the parameter \code{optimParams}, which is forwarded to the
\code{control} parameter of the function \code{DEoptim::DEoptim}.
See \code{DEoptim::DEoptim.control} for more information.
}

